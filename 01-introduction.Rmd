# Introduction {#chap:introduction}

<!-- I have no idea why setting this in the preamble is ignored: -->

{ LATEX \renewcommand{\mathbf}[1]{\mathbfup{#1}} }
{ LATEX \renewcommand{\boldsymbol}[1]{\mathbfit{#1}} }

<!-- (C) 2020 Marek Gagolewski, https://www.gagolewski.com -->


<!-- TODO: citations


-->



## What is Machine Learning?

An *algorithm* is a well-defined sequence of instructions that,
for a given sequence of input arguments,
yields some desired output.
In other words, it is a specific recipe for what we call
a *function* in mathematics.
Unfortunately, algorithm development is a tedious task. We need to be
super-precise about covering all the possible scenarios and modelling them
accurately. When we are to build a self-driving vehicle, we need to be
ready for an infinite
number of situations that can arise on the road.
When we are to build a system for diagnosing tumour on medical images,
there are so many decisions
to make of whether should we consider a particular area suspicious,
how does it relate to the neighbouring cells, etc.


In *machine learning* (ML), we build and study computer algorithms
that make *predictions* or *decisions* but which are not
manually programmed. Moreover, some algorithms might also be able
to *discover* new interesting facts about a problem instance at hand.

*Learning*, however, needs some material based upon which
new knowledge is to be developed.
In other words, we need *data*.



### Data Sources

Information can come from various sources, e.g., physical sensors,
files, databases, (pseudo)random number generators
and it can be of different forms, e.g., vectors, matrices
and other tensors, graphs, audio/video streams, text etc.
With the advent of the internet era, data have become ubiquitous.

{ BEGIN exercise }
Think of how much information you consume and generate when you
interact with your social media or news feeds every day.
{ END exercise }



Here are some application domains where machine learning has already proven
itself very useful:

* Financial services (banking, insurance, investment funds)
* Oil and gas and other energy (solar, mining)
* Real estate
* Pharmaceuticals
* Advertising
* Transportation
* Retail
* Healthcare
* Food production

{ BEGIN exercise }
Think of different ways in which
these sectors could benefit from ML solutions.
{ END exercise }

To be frank, the above list was generated by duckduckgoing
the "biggest industries" query. That was a very easy task;
ML is already everywhere.
Basically, wherever we have data and there is a need to improve
some processes or discover new aspects about a problem domain,
there is a place for ML solutions.

Of course, it's not all about business revenue (luckily).
We can do a lot of great work for greater good;
with the increased availability of open data,
everyone can be a reporter, an engaged citizen that seeks for truth.
There are NGOs.
Finally, there are researchers (remember that the  main role of most
universities is still to spread the advancement of knowledge and not to make money!)
that need these methods to make new discoveries, e.g., in psychology,
sociology, agriculture, engineering, biotechnology, pharmacy, medicine, genetics,
you name it.

<!-- * Life science and medical data analysis -->
<!-- * Scientific simulations -->
<!-- * Genomics -->



### Main Types of Machine Learning Problems

Machine Learning problems include, but are not limited to:

- *Supervised learning* -- for every input point (e.g., a photo)
there is an associated desired output (e.g., whether it depicts a crosswalk
or how many cars can be seen on it);
in other words, there is a "teacher" ready to instruct us
about what is  the expected behaviour in a given context.


- *Semi-supervised learning* -- some inputs are labelled, other ones
are not (definitely a less laborious/cheaper scenario).



- *Unsupervised learning* -- inputs are unlabelled; the aim is to discover
the underlying structure in the data (e.g., automatically group customers
w.r.t. common behavioural patterns);
think about how much you learnt by just interacting with your
environment by wandering here and there.



- *Reinforcement learning* -- learn to act based on a
feedback given after the actual decision was made
such as "that was nice! well done! look at you go!"
(e.g., learn to play some video game by testing different hypotheses
what to do in order to prosper/survive as long as possible).



In the course of this book, we're going to take a deep dive into
the machine learning algorithms that stood the test of time
and that still are used -- with modifications -- by researchers
and practitioners.
We will learn about how we can use them for improving different processes.
Importantly, we will also get to know their limitations.

Arranging the material so as to maximise its usefulness
(we'd like to empower ourselves with a set of tools that can get some work done),
lay solid groundwork for further studies and
develop the adjoining skills (the practice of data analysis certainly
requires us to learn programming and be able to read and understand mathematical
notation) is a multi-objective optimisation problem.
A problem involving many constraints though;
as this is an introductory course, we obviously cannot cover everything,
not yet. In particular, we will be learning maths and programming "from scratch",
our space-time is limited etc. We also want to enjoy our journey -- to have
some fun knowing that big projects never come into being in a day or seven.

Therefore, this time we will limit ourselves "just" to supervised and unsupervised
learning, as these are the most common  instances.




## Input Data, **X** -- Formalism




Let $\mathcal{X}=\{\boldsymbol{x}^{(1)},\dots,\boldsymbol{x}^{(n)}\}$
be an input sample ("a database")
that contains information on $n$ entities or phenomena (in their entirety
or at different points in time or space).
Most often we assume that each object in $\mathcal{X}$, say $\boldsymbol{x}^{(i)}$,
is represented by means of a sequence of $p$ real numbers (for some $p$).
We denote this fact as $\boldsymbol{x}^{(i)}\in \mathbb{R}^p$.



Remark.

:   Here, the "$\in$" symbol  stand for "*is in*" or "*is a member of*",
    $\mathbb{R}$ denotes the set of real numbers (the one that features,
    $0$, $-358745.2394$, $42$ and $\pi$, amongst uncountably many others)
    and $\mathbb{R}^p$ is the set of real-valued sequences of length $p$
    (i.e., $p$ such numbers considered at a time).
    For instance, $\mathbb{R}^2$ includes pairs such as
    $(1, 2)$, $(-6.4,0)$ and $(1/3, 10^{3})$.
    More generally, we write $(x_1,\dots,x_p)\in\mathbb{R}^p$,
    where $x_j\in\mathbb{R}$ is the $j$-th component of the sequence,
    for any $j=1,\dots,p$.

    To emphasise on the fact that $(x_1,\dots,x_p)$ is not an "atomic"
    entity, but a one that is comprised of many components,
    we will use bold fonts for denoting whole sequences, e.g.,
    write $\boldsymbol{x}=(x_1,\dots,x_p)$.

    If $\mathbf{x}\in \mathbb{R}^p$, then we often say
    that $\mathbf{x}$ is
    *a sequence of $p$ numbers*,
    *a (numeric) $p$-tuple*,
    *a $p$-dimensional real vector*,
    *a point in a $p$-dimensional real space*,
    or *an element of a real $p$-space* etc.

    We explain the basics of notation convention used throughout this book
    (and in most math works in general) in Appendix \@ref(appendix:convention).



At a first glance, such a representation might seem overly simplistic,
especially if we'd wish to store information on  "very complex" objects.
However, it turns out that in most cases expressing them as
*feature vectors* (i.e., establishing a set of numeric attributes
that best describe them in a task at hand) is not only natural
but also perfectly sufficient for achieving whatever we aim at.

<!--(\*) There are some algorithms such as Multidimensional Scaling,
Locally Linear Embedding, IsoMap etc.
that can do that automagically.-->


{ BEGIN exercise }
Consider the following problems:

1. How would you represent a patient in a clinic
(for the purpose of conducting research in cardiology)?

2. How would you represent a car in an insurance company's database
(for the purpose of determining how much a driver should pay annually
for the mandatory policy)?

3. How would you represent a student in an university (for the purpose
of granting them scholarships)?

In each case, list a few numeric features that best describe the reality
of concern. Note that descriptive labels can always be *encoded* as numbers,
e.g., female = 1, male = 2.
{ END exercise }




The setting we've established is *abstract* in the sense that
there might be different realities *hidden* behind the symbols we use.
This is exactly what maths is for -- creating *abstractions* or *models*
of complex entities/phenomena so that they can be much more easily manipulated
or understood.

<!--  -->

This is very powerful -- spend a moment
contemplating how many real-world situations fit into our framework.
In particular the last chapters are devoted to the less-obvious data domains,
for instance text or image/video data, e.g., a 1920Ã—1080 pixel image
can be "unwound" to a "flat" sequence of length 2,073,600.



. . .

The whole dataset consisting of $n$ *observations* (samples, cases, records)
and $p$ *features* (variables, attributes, characteristics)
can be written as an ($n\times p$)-matrix:
\[
\mathbf{X}=
\left[
\begin{array}{cccc}
x_{1,1} & x_{1,2} & \cdots & x_{1,p} \\
x_{2,1} & x_{2,2} & \cdots & x_{2,p} \\
\vdots & \vdots & \ddots & \vdots \\
x_{n,1} & x_{n,2} & \cdots & x_{n,p} \\
\end{array}
\right]
\]
Mathematically, we denote this as $\mathbf{X}\in\mathbb{R}^{n\times p}$
(read "$\mathbf{X}$ is a real-valued matrix with $n$ rows and $p$ columns").


Remark.

: A *matrix* is an array of rectangular shape, with items
arranged in rows and columns.
In cases such as this we say that we deal with *structured (tabular) data*
(think: Excel/Calc spreadsheets, SQL tables etc.).


For example, let's consider the Wine Quality dataset
(see Appendix \@ref(appendix:datasets) for more details),
that stores information on
11 physicochemical features (amongst others -- see below)
of ca. 6500 Portuguese wines
from different wineries.


```{r wines_load,results='hide'}
wine_quality <- read.csv("datasets/wine_quality_all.csv",
    comment.char="#")
X <- wine_quality[, 1:11] # extract the first 11 columns
X <- as.matrix(X) # convert to numeric matrix
head(X) # display the first 6 rows, i.e., X[1:6,]
```

```{r wines_print1,echo=FALSE}
.X <- wine_quality[, 1:11]
.X <- .X[c(1,2,3,4,11)]
names(.X)[4] <- "..."
row.names(.X) <- sprintf("[%d,]", seq_len(nrow(.X)))
.X[4] <- "..."
print(head(.X))
```

We can get to now the dimensionality (shape) of $\mathbf{X}$ by calling:

```{r wines_print2}
dim(X)    # gives n and p, respectively
nrow(X)   # dim(X)[1] â€“ 1st dimension â€“ n
ncol(X)   # dim(X)[2] â€“ 2nd dimension â€“ p
```

Therefore, $\mathbf{X}\in\mathbb{R}^{`r nrow(X)`\times `r ncol(X)`}$,
i.e., $n=`r nrow(X)`$ and $p=`r ncol(X)`$.


Remark.

:   Obviously, displaying $\mathbf{X}$ in its entirety would take up a lot of
    pages. Not only there are so many rows, also the number of columns makes
    the matrix too "wide" -- mainly because
    of the presence of the descriptive feature labels (column names).
    Therefore, when printed out on the console, R will "wrap" the columns to
    fit the page width.

    ```{r wines_print3}
    head(X, 3) # the first 3 rows
    ```


Let's forget about the column labels for the time being, as they
might be distracting use from fully appreciating the abstract
nature of the setting we're trying to develop.


```{r wines_print5}
dimnames(X) <- NULL # drop row and column names
head(X) # show the first 6 rows
```


An element of $\mathbf{X}$ located in the $i$-th row and the $j$-th column,
denoted $x_{i,j}\in\mathbb{R}$,
represents the $j$-th feature of the $i$-th observation,
$i=1,\dots,n$, $j=1,\dots,p$.

For instance, the 3rd wine's volatile acidity (expressed in grams of acetic acid per dmÂ³), $x_{3,2}$, is:

```{r show_iris_elem}
X[3, 2] # 3rd row, 2nd column
```





The third observation (data point, row in $\mathbf{X}$, i.e.,
the 3rd wine in the dataset)
consists of items $(x_{3,1}, \dots, x_{3,p})$ that can be extracted by calling:

```{r show_iris_row}
X[3,]
```



Moreover, the second feature/variable/column (in our case: volatile acidity)
is comprised of
$(x_{1,2}, x_{2,2}, \dots, x_{n,2})$:

```{r show_iris_col}
X[,2]
```


{ BEGIN exercise }
Identify the precise location of the value `r X[3,2]` in all the above
examples.
{ END exercise }


We will sometimes use the following notation to emphasise that
the $\mathbf{X}$ matrix  consists of $n$ rows
or $p$ columns:

\[
\mathbf{X}=\left[
\begin{array}{c}
\mathbf{x}_{1,\cdot} \\
\mathbf{x}_{2,\cdot} \\
\vdots\\
\mathbf{x}_{n,\cdot} \\
\end{array}
\right]
=
\left[
\begin{array}{cccc}
\mathbf{x}_{\cdot,1} &
\mathbf{x}_{\cdot,2} &
\cdots &
\mathbf{x}_{\cdot,p} \\
\end{array}
\right].
\]




Here, $\mathbf{x}_{i,\cdot}$ is a *row vector* of length $p$,
i.e., a $(1\times p)$-matrix:

\[
\mathbf{x}_{i,\cdot} = \left[
\begin{array}{cccc}
x_{i,1} &
x_{i,2} &
\cdots &
x_{i,p} \\
\end{array}
\right].
\]

Moreover, $\mathbf{x}_{\cdot,j}$ is a *column vector* of length $n$,
i.e., an $(n\times 1)$-matrix:

\[
\mathbf{x}_{\cdot,j} = \left[
\begin{array}{cccc}
x_{1,j} &
x_{2,j} &
\cdots &
x_{n,j} \\
\end{array}
\right]^T=\left[
\begin{array}{c}
{x}_{1,j} \\
{x}_{2,j} \\
\vdots\\
{x}_{n,j} \\
\end{array}
\right],
\]

where $\cdot^T$ denotes the *transpose* of a given matrix --
think of this as a kind of rotation; it allows us to introduce a set of
"vertically stacked" objects using a single inline formula.



Remark.

: Details on how to get started with the R environment are provided
in Appendix \@ref(appendix:rintro).
A comprehensive introduction to vector and matrix algebra in R
as well as basic data frame wrangling is given
in Appendices \@ref(appendix:rvector), \@ref(appendix:rmatrix)
and \@ref(appendix:rdf).
From now on, we assume that we are all familiar with this material.





## Unsupervised Learning



In *unsupervised learning* (learning without a teacher),
the input data vectors $\mathbf{x}_{1,\cdot},\dots,\mathbf{x}_{n,\cdot}$
(rows in $\mathbf{X}$) are all we have.
Our aim now is to discover the *underlying structure in the data*,
whatever that means.
For instance, Figure {@fig:unsupervised} depicts a scatter plot
of two selected wine features.
What interesting information can we extract from this figure?
Perhaps not much, this is exactly why we need data mining methods!


```{r unsupervised,echo=FALSE,fig.cap="Unsupervised learning: \"But what it is exactly that I have to do here?\""}
plot(wine_quality[, "chlorides"], wine_quality[, "fixed.acidity"], col="#00000011", pch=16)
#plot(wine_quality[sam, "chlorides"], wine_quality[sam, "fixed.acidity"], col=wc[sam], pch=wp[sam])
```






### Dimensionality Reduction


Certain classes of unsupervised learning
problems are not only intellectually stimulating,
but practically useful at the same time.




In particular, in *dimensionality reduction* we seek a meaningful
*projection* of a high dimensional space (think: a matrix with many columns)
to a space of lower dimension.
For instance, if the output number of features is 2 (or maybe 3 as well),
we will be able to visualise a complex dataset on a standard scatter plot.


```{r princomp,echo=FALSE,fig.cap="Principal component analysis (a dimensionality reduction technique) applied on 5 columns of the `wine_quality` dataset."}
p <- princomp(scale(X[,c(1, 2, 4, 5, 11)]))
wc <- c("#44444422", "#ff000022")[as.numeric(factor(wine_quality$color, levels=c("white", "red")))]
wp <- c(17, 16)[as.numeric(factor(wine_quality$color, levels=c("white", "red")))]
set.seed(123)
sam <- sample(rev(1:nrow(X)))
plot(p$scores[sam,1], p$scores[sam,2], col=wc[sam], pch=wp[sam], xlab="First principal component", ylab="Second principal component")
legend("topright", c("white wine", "red wine"), pch=c(17,16), col=c("black", "red"), bg="white")
```

For instance, Figure {@fig:princomp} depicts the two dimensions "revealed"
by the PCA method (Principal Component Analysis) -- a technique proposed
by the mathematician Karl Pearson (the Father of mathematical statistics)
at the beginning of the 20th century.

It's actually nice to see that the wines of different colours
(see `wine_quality[,"color"]`) form two quite distinct "blobs".
By analysing the results returned by PCA in more detail, we could
better understand the differences in physicochemical features of wines
of different colours (amongst others).

Amongst example dimensionality reduction methods we find:

- multidimensional scaling (MDS),
- kernel PCA,
- t-SNE,
- autoencoders (deep learning).

See, for example, [@esl] for more details.




### Anomaly Detection

Furthermore, in *anomaly detection*, our task is to identify rare,
suspicious, ab-normal or out-standing items.
For example, these can be cars on walkways in a park's security camera footage.

Figure {@fig:anomaly_detection} .......


```{r anomaly_detection,echo=FALSE,fig.cap="Outliers can be thought of anomalies of some sort"}
plot(wine_quality[sam, "chlorides"], wine_quality[sam, "fixed.acidity"], col=wc[sam], pch=wp[sam])
wh <- wine_quality[, "chlorides"]>0.6 | wine_quality[, "fixed.acidity"]>15.5
points(wine_quality[wh, "chlorides"], wine_quality[wh, "fixed.acidity"], col=4, cex=3, pch=4)
legend("topright", c("white wine", "red wine", "outlier"), pch=c(17,16,4), col=c(1,2,4), bg="white")
```


methods, e.g., sample quantiles or hdbscan...


### Clustering

Moreover, the aim of *clustering* is to automatically discover
some *naturally occurring*
subgroups in the data set, compare Figure {@fig:clustering_illustration}.
For example, these may be customers having different shopping patterns
(such as "young parents", "students", "boomers").



```{r clustering_illustration,echo=FALSE,cache=TRUE,fig.cap="NEWS FLASH! SCIENTISTS SHOWED (by writing about it) THAT SOME VERY IMPORTANT THING (Iris dataset) COMES IN THREE DIFFERENT FLAVOURS (by applying the 3-means clustering algorithm)!"}
km <- kmeans(iris[,c(3,2)], centers=3, nstart=10)
plot(iris[,3], iris[,2], ann=FALSE,
    col=km$cluster, pch=km$cluster)
```


We discuss the most seminal clustering techniques
in Chapters \@ref(chap:hclust) (hierarchical agglomerative algorithms)
and \@ref(chap:kmean) (K-means method).




## Supervised Learning


### Desired Outputs, **y**




In supervised learning,
apart from the inputs we are also given the corresponding
reference/desired outputs.

The aim of supervised learning is to try to create an "algorithm" that,
given an input point, generates an output that is as *close* as possible
to the desired one. The given data sample will be used to "train" this "model".

Usually the reference outputs are encoded as individual  numbers (scalars)
or textual labels.

In other words, with each input $\mathbf{x}_{i,\cdot}$ we associate
the desired output $y_i$:

```{r show_iris_sample,echo=-1}
set.seed(123)
# in iris, iris[, 5] gives the Ys
iris[sample(nrow(iris), 3), ]  # three random rows
```





Hence, our dataset is $[\mathbf{X}\ \mathbf{y}]$ --
each object is represented as a row vector
$[\mathbf{x}_{i,\cdot}\ y_i]$, $i=1,\dots,n$:

\[
[\mathbf{X}\ \mathbf{y}]=
\left[
\begin{array}{ccccc}
x_{1,1} & x_{1,2} & \cdots & x_{1,p} & y_1\\
x_{2,1} & x_{2,2} & \cdots & x_{2,p} & y_2\\
\vdots & \vdots & \ddots & \vdots    & \vdots\\
x_{n,1} & x_{n,2} & \cdots & x_{n,p} & y_n\\
\end{array}
\right],
\]

where:

\[
\mathbf{y} = \left[
\begin{array}{cccc}
y_{1} &
y_{2} &
\cdots &
y_{n} \\
\end{array}
\right]^T=\left[
\begin{array}{c}
{y}_{1} \\
{y}_{2} \\
\vdots\\
{y}_{n} \\
\end{array}
\right].
\]


mechanical Turk etc..




outputs can be interpreted by a human being and used (critically) for whatever  purpose
(e.g., a GP for diagnosing illnesses)
* outputs can be provided to other algorithms to take immediate actions
(e.g., buy those market shares immediately!)



### Types of Supervised Learning Problems




Depending on the type of the elements in $\mathbf{y}$
(the domain of $\mathbf{y}$),
supervised learning problems are usually
classified as:

- **regression** -- each $y_i$ is a real number

    e.g., $y_i=$ future market stock price
    with $\mathbf{x}_{i,\cdot}=$ prices from $p$ previous days

- **classification** -- each $y_i$ is a discrete label

    e.g., $y_i=$ healthy (0) or ill (1)
    with $\mathbf{x}_{i,\cdot}=$ a patient's health record


- **ordinal regression** (a.k.a. ordinal classification) -- each $y_i$ is a rank

    e.g., $y_i=$ rating of a product on the scale 1--5
    with $\mathbf{x}_{i,\cdot}=$ ratings of $p$ most similar products



provide links to chapters....


{ BEGIN exercise }
Example Problems -- Discussion:

Which of the following are instances of classification problems? Which of them are regression tasks?

What kind of data should you gather in order to tackle them?

- Detect email spam
- Predict a market stock price
- Predict the likeability of a new ad
- Assess credit risk
- Detect tumour tissues in medical images
- Predict time-to-recovery of cancer patients
- Recognise smiling faces on photographs
- Detect unattended luggage in airport security camera footage
- Turn on emergency braking to avoid a collision with pedestrians
{ END exercise }




A single dataset can become an instance of many different ML problems.

Examples -- the `wine_quality` dataset:

```{r wines_load2,echo=-1}
set.seed(123)
wine_quality[1,]
```


`alcohol` is a numeric (quantitative) variable (see Figure {@fig:wines_regression} for a histogram depicting its empirical distribution):


```{r wines_regression,fig.cap="Quantitative (numeric) outputs lead to regression problems"}
summary(wine_quality$alcohol) # continuous variable
hist(wine_quality$alcohol, main="", col="white"); box()
```

`color` is a quantitative variable with two possible outcomes (see Figure {@fig:wines_binary} for a bar plot):



```{r wines_binary,fig.cap="Quantitative outputs lead to classification tasks"}
table(wine_quality$color) # binary variable
barplot(table(wine_quality$color), col="white", ylim=c(0, 6000))
```


Moreover, `response` is an ordinal variable, representing
a wine's rating as assigned by a wine expert
(see  Figure {@fig:wines_ordinal} for a barplot).
Note that although the ranks are represented with numbers,
we they are not continuous variables. Moreover,
these ranks are something more than just labels -- they are linearly
ordered, we know what's the smallest rank and whats the greatest one.

```{r wines_ordinal,fig.cap="Ordinal variables constitute ordinal regression tasks"}
table(wine_quality$response) # ordinal variable
barplot(table(wine_quality$response), col="white", ylim=c(0, 3000))
```


