# Matrix Algebra in R

<!-- (C) 2020 Marek Gagolewski, https://www.gagolewski.com -->

THIS CHAPTER IS UNDER CONSTRUCTION! EXPECTED DELIVERY DATE: PRETTY PRETTY SOON.
(TO THOSE READING THAT IN THE YEAR 2048).



## Matrices

THIS CHAPTER IS UNDER CONSTRUCTION! EXPECTED DELIVERY DATE: PRETTY PRETTY SOON.
(TO THOSE READING THAT IN THE YEAR 2048).


Vectors are 1-dimensional objects -- they represent sequences of values.

Matrices are 2-dimensional objects -- they represent tabular data.

```{r}
A <- matrix(c(1, 2, 3, 4, 5, 6), byrow=TRUE, nrow=2)
dim(A) # number of rows, number of columns
A
```

```{r}
mode(A)
class(A)
```

Using mathematical notation, above we have defined $\mathbf{A}\in\mathbb{R}^{2\times 3}$:

\[
\mathbf{A}=
\left[
\begin{array}{cccc}
a_{1,1} & a_{1,2} & a_{1,3} \\
a_{2,1} & a_{2,2} & a_{2,3} \\
\end{array}
\right]
=
\left[
\begin{array}{cccc}
1 & 2 & 3 \\
4 & 5 & 6 \\
\end{array}
\right]
\]

---

Other ways to create a matrix:

```{r}
rbind(1:3, 4:6, 7:9) # row bind
rbind(1:3, 4:6, 7:9) # column bind
```


On a side note, R `data.frame`s are similar to matrices but are used
to store tabular data of potentially different types in each column.

---

Note that the omission of `byrow=TRUE` yields the following default behaviour
of the `matrix()` function:

```{r}
matrix(c(1, 2, 3, 4, 5, 6), nrow=2)
```

In other words, elements are read in a column-major manner.

> (\*) This is exactly how R stores the underlying data in RAM.


---

Also take notice of the fact that "flat" vectors are promoted
to column vectors, i.e., matrices with one column:

```{r}
as.matrix(1:3)
```

---

$\mathbf{A}^T$ denotes the matrix *transpose*:

```{r}
t(A)
```

Hence, $\mathbf{B}=\mathbf{A}^T$ is a matrix such that $b_{i,j}=a_{j,i}$.

In other words, in the transposed matrix, rows become columns and columns become rows.

## Matrix-Scalar Operations

---

Operations such as $s\mathbf{A}$ (multiplication of a matrix
by a scalar), $-\mathbf{A}$, $s+\mathbf{A}$ etc.
are applied on each element of the input matrix:

```{r}
(-1)*A
```


## Matrix-Matrix Operations

---



If $\mathbf{A},\mathbf{B}\in\mathbb{R}^{n\times p}$
are two matrices of the same sizes, then
$\mathbf{A}+\mathbf{B}$ and
$\mathbf{A}-\mathbf{B}$ are understood elementwise,
i.e., they result in $\mathbf{C}\in\mathbb{R}^{n\times p}$
such that $c_{i,j}=a_{i,j}\pm b_{i,j}$.

```{r}
A-A
```

---

In R (but not when we use mathematical notation),
all other arithmetic, logical and comparison operators are also
applied in an elementwise fashion.

```{r}
A*A
(A>2) & (A<=5)
```


## Matrix Multiplication (\*)

---

Mathematically, $\mathbf{A}\mathbf{B}$
denotes the **matrix multiplication**. It is a very different operation
to the elementwise multiplication.


```{r}
(A <- rbind(c(1, 2), c(3, 4)))
(I <- rbind(c(1, 0), c(0, 1)))
A %*% I # matrix multiplication
```

This is not the same as the elementwise `A*I`.

---

Matrix multiplication can only be performed on two matrices of
*compatible sizes* -- the number of columns in the left matrix must match
the number of rows in the right operand.

Given $\mathbf{A}\in\mathbb{R}^{n\times p}$
and $\mathbf{B}\in\mathbb{R}^{p\times m}$, their multiply is a matrix
$\mathbf{C}=\mathbf{A}\mathbf{B}\in\mathbb{R}^{n\times m}$
such that $c_{i,j}$ is the dot product of the $i$-th row in $\mathbf{A}$
and the $j$-th column in $\mathbf{B}$:
\[
c_{i,j} = \mathbf{a}_{i,\cdot} \cdot \mathbf{b}_{\cdot,j}
= \sum_{k=1}^p a_{i,k} b_{k, j}
\]
for $i=1,\dots,n$ and $j=1,\dots,m$.

---

> (\*) Note that $\mathbf{A}^T \mathbf{A}$
gives the matrix that consists of the dot products of all the pairs
of columns in $\mathbf{A}$.

```{r}
crossprod(A) # same as t(A) %*% A
```

In the next chapter we will learn about the Pearson linear
correlation coefficient which can be beautifully expressed this way.


> (\*) As an exercise, I recommend that you multiply
a few simple matrices of sizes $2\times 2$, $2\times 3$, $3\times 2$ etc.
using pen and paper and check the results in R. This will become easy
once you get some practice.

<!-- TODO: graphical interpretation -->


---

Also remember that, mathematically,
*squaring* a matrix is done in terms of matrix multiplication,
i.e., $\mathbf{A}^2 = \mathbf{A}\mathbf{A}$.

It can only be performed on *square* matrices, i.e., ones with the same number
of rows and columns.

This is again different than R's elementwise `A^2`.


<!-- TODO? Matrix inverse?? Do we need it? we might for linear regression, but it's already too much -->

<!-- TODO? Matrix ops and the recycling rule -->


## Matrix-Vector Operations

---

Mathematically, there is no generally agreed upon
convention defining arithmetic operations between matrices and vectors.

(\*) The only exception is the  matrix -- vector multiplication in the case
where a vector is a column or a row vector, i.e., in fact, a matrix.

Hence, given $\mathbf{A}\in\mathbb{R}^{n\times p}$ we may write
$\mathbf{A}\mathbf{x}$
only if $\mathbf{x}\in\mathbb{R}^{p\times 1}$ is a column vector.

Similarly, $\mathbf{y}\mathbf{A}$ makes only sense
whenever $\mathbf{y}\in\mathbb{R}^{1\times n}$ is a row vector.

> Please take notice of the fact that we consistently
discriminate between different bold math fonts and letter cases:
$\mathbf{X}$ is a matrix, $\mathbf{x}$ is a row or column vector
(still a matrix, but a sequence-like one)
and $\boldsymbol{x}$ is an ordinary vector (1-dimensional sequence).

> This is why, e.g., the $i$-th row of $\mathbf{X}$ is denoted
with $\mathbf{x}_{i,\cdot}$ -- to emphasise that it is a row vector.

<!-- in R an object of type vector gets promoted to a column vector, i.e., a matrix with 1 column -->



---

However, in R, we might sometimes wish to vectorise
an arithmetic operation between a matrix and a vector in a row- or column-wise
fashion.

For example, if $\mathbf{A}\in\mathbb{R}^{n\times p}$
and $\mathbf{m}\in\mathbb{R}^{1\times p}$ is a row vector,
we might want to subtract $m_i$ from each element in the $i$-th column.

Here, the `apply()` function comes in handy:

* `apply(A, 1, f)` applies a given function $f$ on each *row* of $\mathbf{A}$.
* `apply(A, 2, f)` applies a given function $f$ on each *column* of $\mathbf{A}$.

Usually, either $f$ returns a single value (when we wish to aggregate
all the elements in a row/column) or returns the same number of values
(when we wish to transform a row/column).

---

Example: to create a *centred* version of a given matrix,
we need to subtract from each element the arithmetic mean of its column.

```{r}
(A <- cbind(c(1, 2), c(2, 4), c(5, 8)))
(m <- apply(A, 2, mean)) # same as colMeans(A)
t(apply(A, 1, function(r) r-m)) # note the transpose here
```

---

The above is equivalent to:

```{r}
apply(A, 2, function(c) c-mean(c))
```





## Further Reading

#### {.allowframebreaks .unnumbered}

Recommended further reading:

- [@Rintro]

Other:

- [@mml]
- [@rprogdatascience]
- [@r4ds]
