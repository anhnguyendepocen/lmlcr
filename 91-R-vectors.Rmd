# Vector Algebra in R

<!-- (C) 2020 Marek Gagolewski, https://www.gagolewski.com -->


## Motivation

---

Vector and matrix algebra provides us with a convenient language for
expressing computations on tabular data.

Vector and matrix algebra operations are supported by every
major programming language -- either natively (e.g., R, Matlab, GNU Octave, Mathematica)
or via an additional library/package (e.g, Python with numpy, tensorflow or pytorch;
C++ with Eigen/Armadillo; C, C++ or Fortran with LAPACK).

Using matrix notation leads to a more concise and readable code.
It might also be faster to compute.

---

For instance, given two vectors $\boldsymbol{x}=(x_1,\dots,x_n)$
and $\boldsymbol{y}=(y_1,\dots,y_n)$ like:

```{r}
x <- c(1.5, 3.5, 2.3,-6.5)
y <- c(2.9, 8.2,-0.1, 0.8)
```

Instead of writing:

```{r}
s <- 0
n <- length(x)
for (i in 1:n)
    s <- s + (x[i]-y[i])^2
sqrt(s/n)
```

to mean:

\[
\sqrt{\frac{1}{n} \sum_{i=1}^n (x_i-y_i)^2}
\]

---

we'd rather write:

```{r}
sqrt(mean((x-y)^2))
```

or even:

\[
\frac{1}{\sqrt{n}} \|\boldsymbol{x}-\boldsymbol{y}\|_2
\]


In order to be able to read such a notation,
we only have to get to know the "building blocks". There are just a few
of them, but it takes some time to become comfortable with them.


---

Also note that vectorised code is much faster and much more readable than the `for` loop-based one:

```{r,cache=TRUE,benchmarkvectorised}
library("microbenchmark")
x <- runif(10000) # 10000 random numbers in [0,1]
y <- runif(10000)
print(microbenchmark(
    t1={s <- 0; n <- length(x);
        for (i in 1:n) s <- s + (x[i]-y[i])^2; sqrt(s/n)},
    t2=sqrt(mean((x-y)^2))
), signif=3, unit='relative')
```





## Vector-Scalar Operations

---

Vector-scalar arithmetic operations
such as $s\boldsymbol{x}$ (multiplication of a vector $\boldsymbol{x}=(x_1,\dots, x_n)$
by a scalar $s$) result in a vector $\boldsymbol{y}$ such that $y_i=s x_i$, $i=1,\dots,n$.

The same rule holds for, e.g., $s+\boldsymbol{x}$, $\boldsymbol{x}-s$, $\boldsymbol{x}/s$.


```{r}
0.5 * c(1, 10, 100)
10 + 1:5
seq(0, 10, by=2)/10
```

---

By $-\boldsymbol{x}$ we will mean $(-1)\boldsymbol{x}$:

```{r}
-seq(0, 1, length.out=5)
```

---

Note that in R the same rule applies for exponentiation:

```{r}
(0:5)^2 # synonym: (1:5)**2
2^(0:5)
```

However, in mathematics, we are **not** used  to writing
$2^{\boldsymbol{x}}$ or $\boldsymbol{x}^2$.



## Vector-Vector Operations

---

Let $\boldsymbol{x}=(x_1,\dots,x_n)$ and $\boldsymbol{y}=(y_1,\dots,y_n)$ be two vectors of identical lengths.

Arithmetic operations $\boldsymbol{x}+\boldsymbol{y}$ and $\boldsymbol{x}-\boldsymbol{y}$ are performed *elementwise*,
i.e., they result in a vector $\boldsymbol{z}$ such that
$z_i=x_i+y_i$ and $z_i=x_i-y_i$, respectively, $i=1,\dots,n$.

```{r}
x <- c(1,  2,   3,    4)
y <- c(1, 10, 100, 1000)
x+y
x-y
```

---

Although in mathematics we are **not** used to using any special notation
for elementwise multiplication, division and exponentiation, this is available in R.

```{r}
x*y
x/y
y^x
```

---

Moreover, in R the **recycling rule** is applied if we perform elementwise
operations on vectors of *different* lengths -- the shorter
vector is recycled as many times as needed to match the length of the longer
vectors, just as if we were performing:

```{r}
rep(1:3, length.out=12) # recycle 1,2,3 to get 12 values
```

---

```{r}
1:6 * c(1)
1:6 * c(1,10)
1:6 * c(1,10,100)
1:6 * c(1,10,100,1000)
```

Note that a warning is not an error  -- we still get a sensible result.


---

In R:

* comparison operators such as `<` (less than), `<=` (less than or equal),
`==` (equal), `!=` (not equal), `>` (greater than) and `>=` (greater than or equal)
as well as
* logical operators like `&` (and) and `|` (or)

are performed in the same manner as above, i.e.:

* they are elementwise operations and
* recycling rule is applied if necessary.

However, they return *logical* vectors in result.

---


```{r}
1:2 == 1:4 # c(1,2,1,2) == c(1,2,3,4)
z <- c(0, 3, -1, 1, 0.5)
(z >= 0) & (z <= 1)
```

Also note that in R there are 3 (!) logical values:
`TRUE`, `FALSE` and `NA` (not available, missing, null).


---



Generally, operations on `NA`s yield `NA` in result unless other solution
makes sense.

```{r}
c(0, NA, 2)*c(1, 10, 100)
u <- c(TRUE, FALSE, NA)
v <- c(TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, NA, NA, NA)
u & v # elementwise AND (conjunction)
u | v # elementwise OR  (disjunction)
!u    # elementwise NOT (negation)
```

## Other Vector Operations

---

R implement a couple of *aggregation* functions:

* `sum(x)` = $\sum_{i=1}^n x_i=x_1+x_2+\dots+x_n$
* `prod(x)` = $\prod_{i=1}^n x_i=x_1 x_2 \dots x_n$
* `mean(x)` = $\frac{1}{n}\sum_{i=1}^n x_i$ -- arithmetic mean
* `var(x)` = `sum((x-mean(x))^2)/(length(x)-1)` =
$\frac{1}{n-1} \sum_{i=1}^n \left(x_i - \frac{1}{n}\sum_{j=1}^n x_j \right)^2$
-- variance
* `sd(x)` = `sqrt(var(x))` -- standard deviation

see also: `min()`, `max()`, `median()`, `quantile()`.

> Remember that you can always access the R manual by typing
`?functionname`, e.g., `?quantile`.

---

Mathematically, we will also be interested in the following norms:

* Euclidean norm:
\[
\|\boldsymbol{x}\| = \|\boldsymbol{x}\|_2 = \sqrt{ \sum_{i=1}^n x_i^2 }
\]
this is nothing else than the *length* of the vector $\boldsymbol{x}$
* Manhattan (taxicab) norm:
\[
\|\boldsymbol{x}\|_1 = \sum_{i=1}^n |x_i|
\]
* Chebyshev (maximum) norm:
\[
\|\boldsymbol{x}\|_\infty = \max_{i=1,\dots,n} |x_i|
= \max\{ |x_1|, |x_2|, \dots, |x_n| \}
\]

---

```{r}
z <- c(1, 2)
sqrt(sum(z^2)) # or norm(z, "2"); Euclidean
sum(abs(z))    # Manhattan
max(abs(z))    # Chebyshev
```

---

Also note that:

\[
\| \boldsymbol{x}-\boldsymbol{y} \| = \sqrt{
\sum_{i=1}^n \left(x_i-y_i\right)^2
}
\]

gives the *Euclidean distance* (metric) between the two vectors.

```{r}
u <- c(1, 0)
v <- c(1, 1)
sqrt(sum((u-v)^2))
```


---

What is more, given two vectors of identical lengths,
$\boldsymbol{x}$ and $\boldsymbol{y}$,
we define their *dot product* (a.k.a. *scalar, inner product*) as:

\[
\boldsymbol{x}\cdot\boldsymbol{y} = \sum_{i=1}^n x_i y_i.
\]

> This is not the same as elementwise vector multiplication in R.

```{r}
u <- c(1, 0)
v <- c(1, 1)
sum(u*v)
```

> (\*) Note that the squared Euclidean norm of a vector is equal to the dot
product of the vector and itself,
$\|\boldsymbol{x}\|^2 = \boldsymbol{x}\cdot\boldsymbol{x}$.

---

Interestingly, a dot product has a nice geometrical interpretation:

\[
\boldsymbol{x}\cdot\boldsymbol{y} = \|\boldsymbol{x}\| \|\boldsymbol{y}\|
\cos\alpha
\]
where $\alpha$ is the angle between the two vectors.

> Read: it is the product of the lengths of the two vectors
and the cosine of the angle between them.

> You can get the cosine part by computing the dot product of the *normalised*
vectors, i.e., such that their lengths are equal to 1.

---


```{r,echo=FALSE}
par(mar=c(2.5,2,0.5,0.5))
plot(rbind(u,v), xlim=c(0,1), ylim=c(0,1), las=1, ann=FALSE, asp=1)
arrows(0, 0, u[1], u[2])
arrows(0, 0, v[1], v[2])
text(u[1], u[2], sprintf("[%d,%d]", u[1], u[2]), pos=4)
text(v[1], v[2], sprintf("[%d,%d]", v[1], v[2]), pos=4)
```

```{r}
len_u <- sqrt(sum(u^2)); len_v <- sqrt(sum(v^2))
(cos_angle_uv <- (sum(u*v)/(len_u*len_v)))
acos(cos_angle_uv)*180/pi # angle in degs
```


---

Furthermore, R supports numerous mathematical functions, e.g.,
`sqrt()`, `abs()`, `round()`, `log()`, `exp()`, `cos()`, `sin()`.

All of them are vectorised -- when applied on a vector of length $n$,
they yield a vector of length $n$ in result.

```{r}
sqrt(1:9)
```

---

Also note the following operations on *logical* vectors:

```{r}
z <- 1:10
all(z >= 5) # are all values TRUE?
any(z >= 5) # is there any value TRUE?
sum(z >= 5) # how many TRUE values are there?
mean(z >= 5) # what is the proportion of TRUE values?
```

The behaviour of `sum()` and `mean()` is dictated by the fact
that, when interpreted in numeric terms, `TRUE==1`  and `FALSE==0`.





## Further Reading

#### {.allowframebreaks .unnumbered}


Recommended further reading:

- [@Rintro]

Other:

- [@mml]
- [@rprogdatascience]
- [@r4ds]
