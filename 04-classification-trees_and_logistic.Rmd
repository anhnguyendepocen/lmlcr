# Classification with Trees and Linear Models

<!-- (C) 2020 Marek Gagolewski, https://www.gagolewski.com -->


## Introduction

### Classification Task


Let $\mathbf{X}\in\mathbb{R}^{n\times p}$ be an input matrix
that consists of $n$ points in a $p$-dimensional space (each of the $n$ objects
is described by means of $p$ numerical features)

Recall that in supervised learning, with each
$\mathbf{x}_{i,\cdot}$ we associate the desired output $y_i$.

Hence, our dataset is $[\mathbf{X}\ \mathbf{y}]$ --
where each object is represented as a row vector
$[\mathbf{x}_{i,\cdot}\ y_i]$, $i=1,\dots,n$:

\[
[\mathbf{X}\ \mathbf{y}]=
\left[
\begin{array}{ccccc}
x_{1,1} & x_{1,2} & \cdots & x_{1,p} & y_1\\
x_{2,1} & x_{2,2} & \cdots & x_{2,p} & y_2\\
\vdots & \vdots & \ddots & \vdots    & \vdots\\
x_{n,1} & x_{n,2} & \cdots & x_{n,p} & y_n\\
\end{array}
\right].
\]


. . .



In this chapter we are still  interested in  **classification** tasks;
we assume that each $y_i$ is a descriptive label.





Let's assume that we are faced with **binary classification** tasks.

Hence, there are only two possible labels that we traditionally denote with $0$s and $1$s.

For example:

0       | 1
--------|------------
no      | yes
false   | true
failure | success
healthy | ill







Let's recall the synthetic 2D dataset from the previous chapter
(true decision boundary is at $X_1=0$), see Figure {@fig:synthetic}.


```{r synthetic,echo=FALSE,fig.cap="A synthetic 2D dataset with the true decision boundary at $X_1=0$"}
set.seed(123)
n0 <- 50 # n0 points in class 0
n1 <- 50 # n0 points in class 0
Xs <- rbind(
    cbind(rnorm(n0, -1, 1), rnorm(n0, 0, 1)), # N( (-1, 0), (1, 1) )
    cbind(rnorm(n1, +1, 1), rnorm(n1, 0, 1))  # N( (+1, 0), (1, 1) )
)
Ys <- factor(rep(c("0", "1"), c(n0, n1)))

plot(Xs[,1], Xs[,2], col=Ys, pch=c(1,2)[Ys], xlab="X1", ylab="X2", asp=1)
legend("topleft", col=c(1,2), pch=c(1,2), legend=c("Class 0", "Class 1"), bg="white")
abline(v=0, lty=3, col="blue")
```








### Data




For illustration, we'll be considering the Wine Quality dataset
(white wines only):


```{r load1,cache=TRUE}
wines <- read.csv("datasets/winequality-all.csv", comment="#")
wines <- wines[wines$color == "white",]
(n <- nrow(wines)) # number of samples
```




The input matrix $\mathbf{X}\in\mathbb{R}^{n\times p}$
consists of the first 10 numeric variables:

```{r load2,dependson='load1',cache=TRUE}
X <- as.matrix(wines[,1:10])
dim(X)
head(X, 2) # first two rows
```







The 11th variable measures the amount of alcohol (in %).

We will convert this dependent variable to a binary one:

- 0 == (`alcohol  < 12`) == lower-alcohol wines
- 1 == (`alcohol >= 12`) == higher-alcohol wines

```{r load3,dependson='load2',cache=TRUE}
# recall that TRUE == 1
Y <- factor(as.character(as.numeric(wines$alcohol >= 12)))
table(Y)
```






60/40% train-test split:

```{r load4,dependson='load3',cache=TRUE}
set.seed(123) # reproducibility matters
random_indices <- sample(n)
head(random_indices) # preview
# first 60% of the indices (they are arranged randomly)
# will constitute the train sample:
train_indices <- random_indices[1:floor(n*0.6)]
X_train <- X[train_indices,]
Y_train <- Y[train_indices]
# the remaining indices (40%) go to the test sample:
X_test  <- X[-train_indices,]
Y_test  <- Y[-train_indices]
```






Let's also compute `Z_train` and `Z_test`, being the standardised versions of `X_train`
and `X_test`, respectively.

```{r load5,dependson='load4',cache=TRUE}
means <- apply(X_train, 2, mean) # column means
sds   <- apply(X_train, 2, sd)   # column standard deviations
Z_train <- t(apply(X_train, 1, function(c) (c-means)/sds))
Z_test  <- t(apply(X_test,  1, function(c) (c-means)/sds))
```







```{r loaded,dependson='load5',cache=TRUE}
get_metrics <- function(Y_pred, Y_test)
{
    C <- table(Y_pred, Y_test) # confusion matrix
    stopifnot(dim(C) == c(2, 2))
    c(Acc=(C[1,1]+C[2,2])/sum(C), # accuracy
      Prec=C[2,2]/(C[2,2]+C[2,1]), # precision
      Rec=C[2,2]/(C[2,2]+C[1,2]), # recall
      F=C[2,2]/(C[2,2]+0.5*C[1,2]+0.5*C[2,1]), # F-measure
      # Confusion matrix items:
      TN=C[1,1], FN=C[1,2],
      FP=C[2,1], TP=C[2,2]
    ) # return a named vector
}
```






Let's go back to the K-NN algorithm.

```{r fnn1}
library("FNN")
Y_knn5   <- knn(X_train, X_test, Y_train, k=5)
Y_knn9   <- knn(X_train, X_test, Y_train, k=9)
Y_knn5s  <- knn(Z_train, Z_test, Y_train, k=5)
Y_knn9s  <- knn(Z_train, Z_test, Y_train, k=9)
```

Recall the quality metrics we have obtained previously (as a point of reference):

```{r fnn2}
cbind(
    Knn5=get_metrics(Y_knn5, Y_test),
    Knn9=get_metrics(Y_knn9, Y_test),
    Knn5s=get_metrics(Y_knn5s, Y_test),
    Knn9s=get_metrics(Y_knn9s, Y_test)
)
```


In this chapter we discuss the following simple and educational
(yet practically useful)
classification algorithms:

- *decision trees*,
- *binary logistic regression*.




## Decision Trees

### Introduction


Note that a K-NN classifier discussed in the previous chapter
is **model-free**.
The whole training set must be stored and referred to at all times.

Therefore, it doesn't *explain* the data we have -- we may use it solely
for the purpose of *prediction*.


Perhaps one of the most interpretable (and hence human-friendly) models
consist of decision rules of the form:

**IF $x_{i,j_1}\le v_1$ AND ... AND $x_{i,j_r}\le v_r$ THEN $\hat{y}_i=1$.**

These can be organised into a **hierarchy** for greater readability.

This idea inspired the notion of **decision trees** [@cart].






```{r plot_rpart,echo=FALSE,fig.cap="The simplest decision tree for the synthetic 2D dataset and the corresponding decision boundaries"}
library("rpart")
library("rpart.plot")
set.seed(123)



plot_rpart <- function(ts, XYs) {
  xx1 <- seq(-4, 4, length.out=250)
  xx2 <- seq(-4, 4, length.out=250)
  xx <- expand.grid(xx1, xx2)

  dimnames(xx)[[2]] <- names(XYs)[1:2]

  yy <- predict(ts, data.frame(xx, names=c("V1", "V2")), type="class")
  image(xx1, xx2, matrix(as.numeric(yy)-1, nrow=length(xx1), ncol=length(xx2)),
        col=c("#00000044", "#ff000044"), xlab="X1", ylab="X2", asp=1)


  points(Xs[,1], Xs[,2], col=Ys, pch=c(1,2)[Ys])
  legend("topleft", col=c(1,2), pch=c(1,2), legend=c("Class 0", "Class 1"), bg="white")
  abline(v=0, lty=3, col="blue")
}


XYs <- as.data.frame(cbind(Xs, Y=as.numeric(as.character(Ys))))
names(XYs) <- c("X1", "X2", "Y")
cp <- 0.5
ts <- rpart(Y~., data=XYs, method="class", cp=cp)
par(mfrow=c(1,2))
plot_rpart(ts, XYs)
par(mar=c(0,0,0,0))
par(ann=FALSE)
rpart.plot(ts)
```


Figure {@fig:plot_rpart2} depicts a very simple decision tree
for the aforementioned synthetic dataset.
There is only one decision boundary (based on $X_1$) that splits
data into the "left" and "right" sides.
Each tree node reports 3 pieces of information:

- dominating class (0 or 1)
- (relative) proportion of 1s  represented in a node
- (absolute) proportion of all observations in a node




Figures {@fig:plot_rpart2} and {@fig:plot_rpart3} depict
trees with more decision rules.
Take a moment to contemplate how the corresponding decision boundaries
changed with the introduction of new decision rules.


```{r plot_rpart2,echo=FALSE,fig.cap="A more complicated decision tree for the synthetic 2D dataset and the corresponding decision boundaries"}
cp <- 0.01
ts <- rpart(Y~., data=XYs, method="class", cp=cp)
par(mfrow=c(1,2))
plot_rpart(ts, XYs)
par(mar=c(0,0,0,0))
par(ann=FALSE)
rpart.plot(ts)
```




```{r plot_rpart3,echo=FALSE,fig.cap="An even more complicated decision tree for the synthetic 2D dataset and the corresponding decision boundaries"}
cp <- 0.001
control <- list(minsplit=1, minbucket=5)
ts <- rpart(Y~., data=XYs, method="class", cp=cp, control=control)
par(mfrow=c(1,2))
plot_rpart(ts, XYs)
par(mar=c(0,0,0,0))
par(ann=FALSE)
rpart.plot(ts, tweak=1.05)
```






### Example in R






We will use the `rpart()` function from the `rpart` package
to build a classification tree.

```{r rpart_load}
library("rpart")
library("rpart.plot")
set.seed(123)
```

`rpart()` uses a formula (`~`) interface, hence it will be easier
to feed it with data in a data.frame form.

```{r xy_data}
XY_train <- cbind(as.data.frame(X_train), Y=Y_train)
XY_test <- cbind(as.data.frame(X_test), Y=Y_test)
```





Fit and plot a decision tree, see Figure {@fig:plot_rpart1}.

```{r plot_rpart1,fig.height=5,echo=-(1:2),fig.cap="A decision tree for the `wines` dataset"}
par(mar=c(0,0,0,0))
par(ann=FALSE)
t1 <- rpart(Y~., data=XY_train, method="class")
rpart.plot(t1, tweak=1.1, fallen.leaves=FALSE, digits=3)
```


We can build  less or more complex trees by playing
with the `cp` parameter, see Figures {@fig:plot_rpart222}
and {@fig:tree333}.

```{r plot_rpart222,echo=-(1:2),fig.cap="A (simpler) decision tree for the `wines` dataset"}
par(mar=c(0,0,0,0))
par(ann=FALSE)
# cp = complexity parameter, smaller → more complex tree
t2 <- rpart(Y~., data=XY_train, method="class", cp=0.1)
rpart.plot(t2, tweak=1.1, fallen.leaves=FALSE, digits=3)
```


```{r tree333,fig.height=8,echo=-(1:2),fig.cap="A (more complex) decision tree for the `wines` dataset"}
par(mar=c(0,0,0,0))
par(ann=FALSE)
# cp = complexity parameter, smaller → more complex tree
t3 <- rpart(Y~., data=XY_train, method="class", cp=0.00001)
rpart.plot(t3, tweak=1.1, fallen.leaves=FALSE, digits=3)
```

Trees with few decision rules actually are very nicely interpretable.
On the other hand, plotting of the complex ones is just hopeless;
we should treat them as "black boxes" instead.



<!--
The fitted model is rather... simple.

Only the `alcohol` variable is taken into account.


Well note how these two distributions are shifted:

```{r,echo=-1}
#vioplot::vioplot(alcohol~Y, data=XY_train,
#    horizontal=TRUE)
```





-->

Let's make some predictions:

```{r predict_rpart1}
Y_pred <- predict(t1, XY_test, type="class")
get_metrics(Y_pred, Y_test)
```



```{r predict_rpart222}
Y_pred <- predict(t2, XY_test, type="class")
get_metrics(Y_pred, Y_test)
```


```{r tree333pred}
Y_pred <- predict(t3, XY_test, type="class")
get_metrics(Y_pred, Y_test)
```


Remark.

: (\*) Interestingly, `rpart()` also provides us with information
about the importance degrees of each independent variable.

```{r importances}
t1$variable.importance/sum(t1$variable.importance)
```

















### A Note on Decision Tree Learning




Learning an optimal decision tree is a computationally hard problem
-- we need some heuristics.

Examples:

* ID3 (Iterative Dichotomiser 3) [@id3]
* C4.5 algorithm [@c45]
* CART by Leo Breiman et al., [@cart]

(\*\*) Decision trees are most often constructed by a *greedy*, *top-down*
*recursive partitioning*, see., e.g., [@rpart].






<!--

## TODO Random Forests and XGBoost

## ...





just show how to use it

boosting

bagging

```{r}
#library("randomForest")
#rf <- randomForest(X_train, Y_train)
#Y_pred <- predict(rf, X_test)
#get_metrics(Y_pred, Y_test)
```






```{r}
#library("xgboost")
#xg <- xgboost(X_train, Y_train)
#Y_pred <- predict(xg, X_test)
#get_metrics(Y_pred, Y_test)
```

-->






## Binary Logistic Regression

### Motivation





Recall that for a regression task, we fitted a very simple family of models
-- the linear ones -- by minimising the sum of squared residuals.

This approach was pretty effective.

(Very) theoretically, we could treat the class labels as numeric $0$s and $1$s
and apply regression models in a binary classification task.



```{r lm1,dependson='loaded',echo=-1,cache=TRUE}
set.seed(123)
XY_train_r <- cbind(as.data.frame(X_train),
    Y=as.numeric(Y_train)-1 # 0.0 or 1.0
)
XY_test_r <- cbind(as.data.frame(X_test),
    Y=as.numeric(Y_test)-1 # 0.0 or 1.0
)
f_r <- lm(Y~density+residual.sugar+pH, data=XY_train_r)
```





```{r lm2,dependson='lm1',cache=TRUE}
Y_pred_r <- predict(f_r, XY_test_r)
summary(Y_pred_r)
```

The predicted outputs, $\hat{Y}$, are arbitrary real numbers,
but we can convert them to binary ones by checking if, e.g., $\hat{Y}>0.5$.

```{r lm3,dependson='lm2',cache=TRUE}
Y_pred <- as.numeric(Y_pred_r>0.5)
round(get_metrics(Y_pred, XY_test_r$Y), 3)
```



Remark.

: (\*) The threshold $T=0.5$  could even be treated as a free parameter
we optimise for (w.r.t. different metrics over the validation sample),
see Figure {@fig:lm3b}.

```{r lm3b,echo=FALSE,cache=TRUE,dependson='lm3',cache=TRUE,fig.cap="Quality metrics for a binary classifier \"Classify X as 1 if $f(X)>T$ and as 0 if $f(X)\\le T$\""}
set.seed(123)
f_r <- lm(Y~density+residual.sugar+pH, data=XY_train_r)
Y_pred_r <- predict(f_r, XY_test_r)
Ts <- seq(0.1, 0.85, by=0.05)
Ps <- as.data.frame(t(sapply(Ts, function(t) {
  Y_pred <- as.numeric(Y_pred_r>t)
  get_metrics(factor(Y_pred, levels=c("0", "1")), factor(XY_test_r$Y, levels=c("0", "1")))
})))

matplot(Ts, Ps[,1:4], xlab="T", ylab="Metric", type="l", ylim=c(0,1))
legend("bottomleft", legend=names(Ps[,1:4]), col=1:4, lty=1:4, ncol=2, bg="white")
```


Despite we can, we shouldn't use linear regression for classification.
Treating class labels  "0" and "1" as ordinary real numbers just doesn't
cut it -- we intuitively feel that we are doing something *ugly*.
Luckily, there is a better, more meaningful approach that
still relies on a linear model, but has the *right* semantics.






### Logistic Model




Inspired by this idea, we could try modelling
the ***probability* that a given point belongs to class $1$**.

This could also provide us with the *confidence* in our prediction.

Probability is a number in $[0,1]$, but the outputs of a linear model are arbitrary real numbers.

However, we could transform those real-valued outputs by means
of some function $\phi:\mathbb{R}\to[0,1]$ (preferably S-shaped == sigmoid),
so as to get:

\[
\Pr(Y=1|\mathbf{X},\boldsymbol\beta)=\phi(\beta_0 + \beta_1 X_1 + \beta_2 X_2 + \dots + \beta_p X_p)
\]


Remark.

: The above reads as "Probability that $Y$ is from class 1 given $\mathbf{X}$
and $\boldsymbol\beta$".




A popular choice is the **logistic sigmoid function**,
see Figure {@fig:sigmoid}:

\[
\phi(y) = \frac{1}{1+e^{-y}} = \frac{e^y}{1+e^y}
\]

```{r sigmoid,echo=FALSE,cache=TRUE,fig.cap="The logistic sigmoid function, $\\varphi$"}
xxx <- seq(-3, 3, length.out=101)
yyy <- 1/(1+exp(-xxx))
plot(xxx, yyy, type='l', xlab='y', ylab=expression(phi(y)), ylim=c(0,1))
abline(v=0, lty=3)
abline(h=c(0, 0.5, 1), lty=3)
```





Hence our model becomes:

\[
Y=\frac{1}{1+e^{-(\beta_0 + \beta_1 X_1 + \beta_2 X_2 + \dots + \beta_p X_p)}}
\]

It is an instance of a **generalised linear model** (glm)
(there are of course many other possible generalisations).


### Example in R




Let us first fit a simple  (i.e., $p=1$) logistic regression model
using the `density` variable. The goodness-of-fit measure used in this
problem will be discussed a bit later.



```{r glm1}
(f <- glm(Y~density, data=XY_train, family=binomial("logit")))
```

"logit" above denotes the inverse of the logistic sigmoid function.
The fitted coefficients are equal to:


```{r glm1b}
f$coefficients
```

Figure {@fig:glm2} depicts the obtained model, which can be written
as:
\[
\Pr(Y=1|x)=\displaystyle\frac{1}{1+e^{-\left(
`r sprintf("%g%+gx", f$coef[1], f$coef[2])`
\right)}
}
\]
with $x=\text{density}$.


```{r glm2,echo=FALSE,cache=TRUE,eval=TRUE,fig.cap="The probability that a given wine is a high-alcohol one given its density; black and red points denote the actual observed data points from the class 0 and 1, respectively"}
xxx <- seq(min(XY_train$density), max(XY_train$density), length.out=101)
yyy <- 1/(1+exp(-(f$coef[1]+f$coef[2]*xxx)))
plot(xxx, yyy, type='l', xlab='density', ylab="P(Y=1|density)", ylim=c(0,1))
points(XY_train$density, jitter(as.numeric(XY_train$Y)-1, 0.1), col=
    c("#00000011", "#ff000011")[as.numeric(XY_train$Y)], pch=16)
abline(h=c(0, 0.5, 1), lty=3)
legend(8, 0.95, legend=sprintf("1/(1+exp(-(%+g%+g*density))", f$coef[1], f$coef[2]), lty=1, bg="white")
```




Some predicted probabilities:


```{r}
round(head(predict(f, XY_test, type="response"), 12), 2)
```

We classify $Y$ as 1 if the corresponding membership probability
is greater than $0.5$.

```{r}
Y_pred <- as.numeric(predict(f, XY_test, type="response")>0.5)
get_metrics(Y_pred, Y_test)
```




And now a fit based on some other input variables:

```{r}
(f <- glm(Y~density+residual.sugar+total.sulfur.dioxide,
    data=XY_train, family=binomial("logit")))
Y_pred <- as.numeric(predict(f, XY_test, type="response")>0.5)
get_metrics(Y_pred, Y_test)
```


{ BEGIN exercise }
Try fitting different models based on other sets of features.
{ END exercise }





### Loss Function: Cross-entropy




The fitting of the model can be written as an optimisation task:

\[
\min_{\beta_0, \beta_1,\dots, \beta_p\in\mathbb{R}}
\frac{1}{n} \sum_{i=1}^n
\epsilon\left(\hat{y}_i, y_i \right)
\]

where $\epsilon(\hat{y}_i, y_i)$ denotes the penalty that measures the
"difference" between the true $y_i$ and its predicted version
$\hat{y}_i=\Pr(Y=1|\mathbf{x}_{i,\cdot},\boldsymbol\beta)$.

In the ordinary regression, we used the squared residual
$\epsilon(\hat{y}_i, y_i) = (\hat{y}_i-y_i)^2$.
In **logistic regression** (the kind of a classifier we are
interested in right now), we use
the **cross-entropy** (a.k.a. **log-loss**, binary cross-entropy),

\[
\epsilon(\hat{y}_i,y_i) = - \left(y_i \log \hat{y}_i + (1-y_i) \log(1-\hat{y}_i)\right)
\]

The corresponding loss function has not only
many nice statistical properties (\*\* related to maximum likelihood
estimation etc.)
but also an intuitive interpretation.




Note that the predicted $\hat{y}_i$ is in $(0,1)$ and the true $y_i$
equals to either 0 or 1.
Recall also that $\log t\in(-\infty, 0)$ for $t\in (0,1)$.
Therefore, the formula for $\epsilon(\hat{y}_i,y_i)$
has a very intuitive behaviour:

- if true $y_i=1$, then the penalty becomes $\epsilon(\hat{y}_i, 1) = -\log(\hat{y}_i)$

    - $\hat{y}_i$ is the probability that the classified input is indeed from class $1$
    - we'd be happy if the classifier outputted $\hat{y}_i\simeq 1$ in this case;
    this is not  penalised as $-\log(t)\to 0$ as $t\to 1$
    - however, if the classifier is totally wrong, i.e., it thinks that
    $\hat{y}_i\simeq 0$, then the penalty will be very high, as $-\log(t)\to+\infty$
    as $t\to 0$


- if true $y_i=0$, then the penalty becomes $\epsilon(\hat{y}_i, 0) = -\log(1-\hat{y}_i)$

    - $1-\hat{y}_i$ is the predicted probability that the input is from class $0$
    - we penalise heavily the case where $1-\hat{y}_i$ is small (we'd be happy
    if the classifier was sure that $1-\hat{y}_i\simeq 1$, because this is the ground-truth)


. . .

(\*) Having said that, let's expand the above formulae.
The task of minimising cross-entropy in binary logistic regression
can be written as:

\[
\min_{\boldsymbol\beta\in\mathbb{R}^{p+1}}
-\frac{1}{n} \sum_{i=1}^n
y_i \log \Pr(Y=1|\mathbf{x}_{i,\cdot},\boldsymbol\beta)
+ (1-y_i) \log(1-\Pr(Y=1|\mathbf{x}_{i,\cdot},\boldsymbol\beta))
\]

Taking into account that:

\[
\Pr(Y=1|\mathbf{x}_{i,\cdot},\boldsymbol\beta)=
\frac{1}{1+e^{-(\beta_0 + \beta_1 x_{i,1}+\dots+\beta_p x_{i,p})}}
\]

we get:

\[
\min_{\boldsymbol\beta\in\mathbb{R}^{p+1}}
-\frac{1}{n}
\sum_{i=1}^n \left(
\begin{array}{r}
y_i \log \displaystyle\frac{1}{1+e^{-(\beta_0 + \beta_1 x_{i,1}+\dots+\beta_p x_{i,p})}}\\
+
(1-y_i) \log \displaystyle\frac{e^{-(\beta_0 + \beta_1 x_{i,1}+\dots+\beta_p x_{i,p})}}{1+e^{-(\beta_0 + \beta_1 x_{i,1}+\dots+\beta_p x_{i,p})}}
\end{array}
\right)
\]

Logarithms are really practitioner-friendly functions,
it holds:

* $\log 1=0$,
* $\log e=1$ (where $e \simeq 2.71828$ is the Euler constant;
note that by writing $\log$ we mean the natural a.k.a. base-$e$ logarithm),
* $\log xy = \log x + \log y$,
* $\log x^p = p\log x$ (this is $\log (x^p)$, not $(\log x)^p$).

These facts imply, amongst others that:

* $\log e^x = x \log e = x$,
* $\log \frac{x}{y} = \log x y^{-1} = \log x+\log y^{-1} = \log x - \log y$
(of course for $y\neq 0$),
* $\log \frac{1}{y} = -\log y$

and so forth. Therefore, the above optimisation problem can be rewritten as:


\[
\min_{\boldsymbol\beta\in\mathbb{R}^{p+1}}
\frac{1}{n}
\sum_{i=1}^n \left(
(1-y_i)\left(\beta_0 + \beta_1 x_{i,1}+\dots+\beta_p x_{i,p}\right)
+\log \left(1+e^{-(\beta_0 + \beta_1 x_{i,1}+\dots+\beta_p x_{i,p})}\right)
\right).
\]

It turns out that there is no analytical formula
for the optimal set of parameters ($\beta_0,\beta_1,\dots,\beta_p$
minimising the log-loss).
In the chapter on optimisation, we shall see that
the solution to the logistic regression can be solved numerically
by means of quite simple iterative algorithms.
The expanded formula has lost the appealing interpretation
of the original one, however, it's more numerically well-behaving,
see, e.g., the `log1p()` function in base R or
`fermi_dirac_0()` in the `gsl` package.

```{r gsl,echo=FALSE,eval=FALSE}
library("gsl")
```

<!-- TODO: cite Goldberg's paper -->





## Outro

### Remarks




Other prominent classification algorithms:

- Naive Bayes and other probabilistic approaches,
- Support Vector Machines (SVMs) and other kernel methods,
- (Artificial) (Deep) Neural Networks.





Interestingly, in the next chapter we will  note that the logistic regression model
is a special case of a *feed-forward single layer neural network*.

We will also generalise the binary logistic regression to the case of
a multiclass classification.


The state-of-the art classifiers called
*Random Forests* and *XGBoost* (see also: *AdaBoost*) are based on decision trees.
They tend to be more accurate but -- at the same time -- they fail to
exhibit the decision trees' important feature: interpretability.

Trees can also be used for regression tasks, see R package `rpart`.



### Further Reading

Recommended further reading: [@islr: Chapters 4 and 8]

Other: [@esl: Chapters 4 and 7 as well as (\*) Chapters 9,  10,  13, 15]
